[{"url":"/thoughts/auto-animation-height.html","frontmatter":{"title":"自动高度过渡动画","description":"我们在做 height 从 0 到自动高度动画的时候经常会碰到障碍，该问题很久有人在 github 上提过这 issues，但一直没有得到有效解答。","date":"2024-07-26 11:45:14","author":"友人A","cover":"https://images.unsplash.com/photo-1506744038136-46273834b3fb?q=80&w=1000","publish":"fasle","tags":[]},"content":"\r\n# 自动高度过渡动画\r\n\r\n我们在做 height 从 0 到自动高度动画的时候经常会碰到障碍，该问题很久有人在 github 上提过这 issues，但一直没有得到有效解答。[https://github.com/w3c/csswg-drafts/issues/626](https://github.com/w3c/csswg-drafts/issues/626) 为此广大的程序员目前有以下几种解决方案：\r\n\r\n## 1. 使用 max-height 代替 height\r\n\r\n这是最常见的解决方法，设置一个足够大的 max-height 值，然后在其上做动画：\r\n\r\n```css\r\n.element {\r\n  overflow: hidden;\r\n  max-height: 0;\r\n  transition: max-height 0.3s ease;\r\n}\r\n\r\n.element.active {\r\n  max-height: 500px; /* 设置一个足够大的值 */\r\n}\r\n```\r\n\r\n**问题**：这种方法的缺陷是需要预先知道内容的大致高度，且实际过渡时间会因为 max-height 值过大而导致动画不够平滑。\r\n\r\n## 2. 使用 transform: scaleY() 方法\r\n\r\n通过变换来实现高度动画：\r\n\r\n```css\r\n.element {\r\n  transform-origin: top;\r\n  transform: scaleY(0);\r\n  transition: transform 0.3s ease;\r\n}\r\n\r\n.element.active {\r\n  transform: scaleY(1);\r\n}\r\n```\r\n\r\n**问题**：这种方法可能会导致子元素内容也被缩放，不是真正的高度过渡。\r\n\r\n## 3. 使用 JavaScript 计算高度\r\n\r\n这是最精确的方法，使用 JavaScript 计算实际高度并设置：\r\n\r\n```javascript\r\nfunction toggleElement(element) {\r\n  const isCollapsed = element.classList.contains('collapsed');\r\n  \r\n  if (isCollapsed) {\r\n    // 展开\r\n    const height = element.scrollHeight;\r\n    element.style.height = '0';\r\n    // 强制重绘\r\n    element.offsetHeight;\r\n    element.style.height = height + 'px';\r\n    element.classList.remove('collapsed');\r\n  } else {\r\n    // 收起\r\n    element.style.height = element.scrollHeight + 'px';\r\n    // 强制重绘\r\n    element.offsetHeight;\r\n    element.style.height = '0';\r\n    element.classList.add('collapsed');\r\n  }\r\n}\r\n```\r\n\r\n**问题**：需要JavaScript配合，不是纯CSS解决方案。\r\n\r\n## 4. 使用 grid-template-rows 动画\r\n\r\n这是一种较新的方法：\r\n\r\n```css\r\n.container {\r\n  display: grid;\r\n  grid-template-rows: 0fr;\r\n  transition: grid-template-rows 0.3s;\r\n}\r\n\r\n.container.open {\r\n  grid-template-rows: 1fr;\r\n}\r\n\r\n.content {\r\n  overflow: hidden;\r\n}\r\n```\r\n\r\n**优点**：这种方法可以实现真正的从0到auto的过渡，且是纯CSS实现。\r\n\r\n## 结论\r\n\r\n目前来看，最理想的解决方案是：\r\n1. 对于简单场景，使用 max-height 方法，尽量精确估计最大高度\r\n2. 对于精确动画，使用 JavaScript 计算实际高度\r\n3. 对于现代浏览器，可以考虑使用 grid-template-rows 方法\r\n\r\n随着 CSS 标准的不断发展，将来可能会有更好的原生解决方案。 ","relativePath":"thoughts/auto-animation-height.md","excerpt":"# 自动高度过渡动画\r\n\r\n我们在做 height 从 0 到自动高度动画的时候经常会碰到障碍，该问题很久有人在 github 上提过这 issues，但一直没有得到有效解答。[https://github.com/w3c/csswg-drafts/issues/626](https://github.com/w3c/csswg-drafts/issues/626) 为此广大的程序员目前有以下几种..."},{"url":"/thoughts/example.html","frontmatter":{"title":"思考随笔：示例","description":"这是一个示例随笔，展示了思考随笔的格式与结构","date":"2024-07-26 11:45:14","author":"友人A","cover":"https://vitepress.dev/vitepress-logo-large.webp","publish":true,"tags":["示例","随笔","VitePress"]},"content":"\r\n# 思考随笔：示例\r\n\r\n## 前言\r\n\r\n这是一个示例随笔，用于展示思考随笔的格式和结构。\r\n\r\n## 主要内容\r\n\r\n在这里，您可以分享您的想法、观点和思考。随笔形式自由，可以是对某个主题的深入探讨，也可以是日常感悟。\r\n\r\n### 引用示例\r\n\r\n> 伟大的思想家往往是那些能够将复杂的概念简单化的人。\r\n> \r\n> — 某位思想家\r\n\r\n### 图片参考\r\n\r\n可以在此处插入相关图片，辅助表达您的想法。\r\n\r\n![图片描述](https://vitepress.dev/vitepress-logo-large.webp)\r\n\r\n## 结语\r\n\r\n这里是随笔的结尾部分，可以总结您的思考或提出新的问题。 ","relativePath":"thoughts/example.md","excerpt":"# 思考随笔：示例\r\n\r\n## 前言\r\n\r\n这是一个示例随笔，用于展示思考随笔的格式和结构。\r\n\r\n## 主要内容\r\n\r\n在这里，您可以分享您的想法、观点和思考。随笔形式自由，可以是对某个主题的深入探讨，也可以是日常感悟。\r\n\r\n### 引用示例\r\n\r\n> 伟大的思想家往往是那些能够将复杂的概念简单化的人。\r\n> \r\n> — 某位思想家\r\n\r\n### 图片参考\r\n\r\n可以在此处插入相关图片，辅助表..."},{"url":"/thoughts/frontend-modularization.html","frontmatter":{"title":"前端模块化","description":"什么是模块化？模块化是指将一个复杂的程序进行分解，划分为若干个独立且可复用的模块，每个模块有特定的功能。","date":"2024-06-17 06:49:08","author":"友人A","cover":"https://images.unsplash.com/photo-1555066931-4365d14bab8c?q=80&w=1000","publish":true,"tags":[]},"content":"\r\n# 前端模块化\r\n\r\n## 什么是模块化？\r\n\r\n模块化是指将一个复杂的程序进行分解，划分为若干个独立且可复用的模块，每个模块有特定的功能，然后通过一定的规则组合在一起，构建出完整的应用程序。模块化有利于代码的可维护性、可复用性、耦合度，并降低项目的复杂度。\r\n\r\n## 模块化解决了哪些问题？\r\n\r\n- 全局污染：命名冲突 - 依赖混乱\r\n- 部分寄生：部分依赖于宿主变量\r\n- 依赖关系：维护困难，无法清晰表达\r\n\r\n## 前端模块化的发展\r\n\r\n### 1. 闭包式自调用函数\r\n\r\n```javascript\r\n(function() {\r\n  // 私有变量和函数\r\n  var privateVariable = 'I am private';\r\n  \r\n  // 公开API\r\n  window.myModule = {\r\n    publicMethod: function() {\r\n      console.log(privateVariable);\r\n    }\r\n  };\r\n})();\r\n```\r\n\r\n虽然简单，但仍然有全局污染，依赖关系不明确。\r\n\r\n### 2. CommonJS\r\n\r\nNode.js采用的模块化标准，使用`require`和`module.exports`：\r\n\r\n```javascript\r\n// 导出模块\r\nmodule.exports = {\r\n  method1: function() {},\r\n  method2: function() {}\r\n};\r\n\r\n// 导入模块\r\nconst myModule = require('./myModule');\r\n```\r\n\r\n特点：同步加载，适合服务器环境。\r\n\r\n### 3. AMD (Asynchronous Module Definition)\r\n\r\nRequireJS实现的异步模块加载方案：\r\n\r\n```javascript\r\ndefine(['dep1', 'dep2'], function(dep1, dep2) {\r\n  return {\r\n    method: function() {\r\n      dep1.method();\r\n    }\r\n  };\r\n});\r\n```\r\n\r\n特点：异步加载，适合浏览器环境。\r\n\r\n### 4. ES Modules\r\n\r\nES6标准的模块系统：\r\n\r\n```javascript\r\n// 导出\r\nexport function method1() {}\r\nexport const variable = 'value';\r\nexport default class MyClass {}\r\n\r\n// 导入\r\nimport MyClass, { method1, variable } from './myModule';\r\n```\r\n\r\n特点：静态分析，编译时加载，支持树摇优化。\r\n\r\n## 为什么模块化如此重要？\r\n\r\n1. **可维护性**：每个模块专注于单一功能\r\n2. **可复用性**：模块可在不同项目中重复使用\r\n3. **可测试性**：独立模块更容易编写测试\r\n4. **代码组织**：清晰的依赖关系和结构\r\n\r\n## 总结\r\n\r\n前端模块化发展经历了全局函数、命名空间、IIFE、CommonJS、AMD、UMD到ES Modules的过程。随着项目规模和复杂度的增长，模块化变得越来越重要，现代前端开发离不开良好的模块化设计。\r\n\r\nES Modules作为JavaScript官方标准模块系统，正逐渐成为主流。无论使用哪种模块化方案，其核心目的都是提高代码质量和开发效率。 ","relativePath":"thoughts/frontend-modularization.md","excerpt":"# 前端模块化\r\n\r\n## 什么是模块化？\r\n\r\n模块化是指将一个复杂的程序进行分解，划分为若干个独立且可复用的模块，每个模块有特定的功能，然后通过一定的规则组合在一起，构建出完整的应用程序。模块化有利于代码的可维护性、可复用性、耦合度，并降低项目的复杂度。\r\n\r\n## 模块化解决了哪些问题？\r\n\r\n- 全局污染：命名冲突 - 依赖混乱\r\n- 部分寄生：部分依赖于宿主变量\r\n- 依赖关系：维护困难..."}]