---
title: 未命名
date: 2024-04-29 19:32:23
description: 这是一篇新文章!
publish: true
tags:
  - 计算机世界观
---

# 序

JavaScript 原本只是个运行在浏览器里的脚本语言，直到 Node.js 把它带到了服务器端，才真正让 JS 拥有了构建大型项目的可能。  
但一个现代项目，往往会依赖数十上百个第三方工具和库，它们之间的依赖关系极为复杂，版本、结构、安装顺序稍有差错就可能导致项目崩溃。

**手动下载解压？维护一堆文件夹？——根本不现实。**

于是，为了让开发者专注于写代码而不是折腾依赖，一个“自动化模块管理工具”就诞生了：包管理器。

它能做的事包括：

- 统一管理项目依赖（记录版本、来源）
- 自动下载安装依赖，解决嵌套依赖问题
- 保证跨平台/多人协作时的依赖一致性
- 支持发布/共享自定义模块到社区生态

如果你今天创建一个前端项目，却没有包管理器的协助，那就像是赤手空拳盖高楼。

# npm-包管理的起点

随着 Node.js 的流行，npm（Node Package Manager）在 2010 年应运而生，并作为其官方包管理器被推出，它理所当然地成为了 Node.js 生态的核心基石。

它的三大核心功能包括：

- 安装和卸载依赖
- 统一管理项目依赖关系
- 从 npm Registry 获取社区包

几乎每一个现代 JavaScript 项目中你见到的包，无论是 `axios`、`vue`、还是 `eslint`，本质上都来自 npm 提供的这一生态系统。

npm 通过一个结构清晰的机制来完成依赖管理：

- **`package.json`**：声明当前项目依赖了什么、用什么脚本启动、作者是谁…
- **`package-lock.json`**：锁定具体依赖版本，保证协作一致性
- **`node_modules/`**：将安装下来的依赖全部放进去，供项目调用

每当你执行 `npm install`，npm 就会：

1. 查阅 `package.json`
2. 下载依赖包（及其依赖的依赖）
3. 写入 `node_modules` 和 `package-lock.json`

## npm 常用指令


## 安装 Node.js 与 npm

npm 是 Node.js 默认的包管理工具 会随 Node.js 一起安装。

1. 访问[Node.js 官网](https://nodejs.org/)
2. 选择适合的版本：

   - LTS 版本：稳定可靠，推荐用于生产环境
   - Current 版本：包含最新特性，可能不够稳定

3. 下载并按照提示完成安装
4. 验证安装是否成功：

```bash
node -v  # 显示Node.js版本
npm -v   # 显示npm版本
```

## 配置 npm

默认情况下，npm 从国外服务器下载包，在国内可能速度较慢。更换为国内镜像源可以显著提升下载速度：

> **国内网络特殊性**：由于众所周知的原因，国内访问某些国外资源可能会较慢。国内技术社区为此提供了优质的镜像服务，如淘宝 NPM 镜像，帮助开发者克服这些网络障碍。

```bash
# 查看当前镜像
npm get registry

# 设置淘宝镜像
npm config set registry https://registry.npmmirror.com/
```


随着项目变得庞大、依赖树变得复杂，npm 在安装速度、依赖结构、锁文件一致性等方面暴露出了明显短板：安装慢、生成大量冗余依赖、在不同机器上容易出现“我的装得和你不一样”的情况。
尽管 npm 在之后不断改进，推出了缓存机制和 `npm ci` 这类优化命令，但还是无法从根本上解决这些痛点。正是在这种背景下，Yarn 和 pnpm 这样的替代品开始崭露头角。

# yarn-优化工具

2016 年，Facebook 内部工程师们终于受够了 npm 安装慢、版本不一致等问题，决定自研一个更可靠、更快的包管理器——Yarn 就此诞生。
它在发布初期就迅速引起了 JavaScript 社区的关注，并成为许多大型项目的默认工具。

Yarn 的设计初衷是：**“让依赖安装变得快速、确定、可重复。”**

为此它带来了几项关键优化：

- **离线缓存机制**：装过的包会被缓存下来，下一次就不需要联网下载，提升了速度；
- **更可靠的锁定文件（`yarn.lock`）**：确保不同人安装出来的依赖版本完全一致；
- **更扁平的依赖结构**：尽量把所有依赖都安装在项目根目录，避免深层嵌套导致的“地狱结构”。

在使用体验上，Yarn 提供了类似 npm 的命令结构：

| 功能     | npm 命令              | Yarn 命令           |
| -------- | --------------------- | ------------------- |
| 安装依赖 | `npm install`         | `yarn install`      |
| 添加依赖 | `npm install axios`   | `yarn add axios`    |
| 移除依赖 | `npm uninstall axios` | `yarn remove axios` |

虽然 Yarn 相比 npm 提供了不少优势，但也有一些不可忽视的遗留问题：

- **依赖仍是扁平结构**：所有包统一堆在根目录的 `node_modules/` 中，容易冲突、冗余。
- **磁盘占用高**：缓存机制虽加快了安装速度，但缓存 + 扁平结构导致重复存储，占用空间严重。
- **缓存不易清理**：即便清除缓存或锁文件，有时依然会遇到依赖错乱的问题。

总的来说，Yarn 曾是 JavaScript 包管理的“黄金标准”，但随着项目规模膨胀，尤其是 **monorepo（单仓多包）** 模式流行，依赖管理愈发复杂，Yarn 的架构已难以胜任更高效的场景。
正是在这个时候，pnpm 出场了。

# pnpm-逻辑革新

pnpm 并没有在 npm 或 Yarn 的旧有逻辑上打补丁，而是从根本上改写了包管理的底层思路。

它采用了一种更“极端”的依赖安装方式：  
**不复制、不平铺、只链接。**

pnpm 会将所有依赖包下载后统一存入一个全局缓存目录，并通过 **硬链接** 的方式，把它们“指向”各个项目的 `node_modules/`。也就是说：  
多个项目如果依赖同一个包，它们用的其实是同一个文件，只是硬链接到各自目录中而已。

这一机制有两个核心优势：

- **省空间**：同一个包只占用一份磁盘存储，不会像 Yarn 那样每个项目都复制一份。
- **装得快**：已有的包不再重复下载，从缓存中直接链接就能用。

而在依赖结构上，pnpm 放弃了 Yarn 的“扁平化”方案，转而采用严格的**模块隔离**策略：每个依赖只能访问它自己声明的依赖，项目也只能访问 `package.json` 中列出的部分，其他任何“意外使用”都会直接报错。这种做法有效避免了“幽灵依赖”（依赖链中的副产物包）污染项目的问题。

为了支撑这种“非扁平”的依赖树，pnpm 使用了一种特殊的 `node_modules` 布局——通过符号链接构建出虚拟结构，让 Node.js 能正确解析路径，同时又不牺牲模块隔离性。

换句话说：pnpm 把“模块共享”和“模块隔离”这两个目标，以最低成本同时达成了。

这也让它在 monorepo 模式下具备天然优势：  
多个包共享一套缓存、依赖互不干扰、安装速度极快，不再因为依赖冲突而满地打补丁。

# # 末

到这里，JavaScript 包管理器的发展脉络就比较清晰了：

- npm 是生态奠基者，胜在稳健、兼容性好；
- Yarn 是阶段性救火队员，修补了早期 npm 的一些痛点；
- pnpm 则是重新思考后的结构重建，用更极致的方式解决了空间冗余、依赖污染等底层问题。

那么在实际项目中该怎么选？

以下是我的建议：

- **个人/中小项目**：  
   如果只是写脚本、做 demo，或者你用的是脚手架（如 Vite）默认配置，**继续使用 npm 并没有问题**。npm7+ 之后性能大幅提升，体验其实已经不差。
- **注重速度和空间优化**：  
   想要**更快安装、更小体积、更严格依赖隔离**，**首选 pnpm**。尤其是频繁开新项目、维护多个仓库的人，用一次就很难回得去。
- **多包管理 / monorepo 工程**：  
   强烈建议使用 **pnpm + workspace**。天然支持 monorepo，不需要借助第三方工具就能完成包间引用、统一安装、跨包依赖管理，非常适合大型项目或组件库开发。
- **团队协作**：  
   无论使用哪种工具，请**全员统一版本 + 锁文件策略**。不同开发者环境差异是最常见的“项目能跑但 CI 崩”的根源。

不管选择哪一套方案，选得合适、用得清楚，才是构建稳定工程的关键。
