---
title: Python-入门
tags:
  - 笔记
  - Python
  - 入门基础
categories:
  - 猎识印记-领域
excerpt: 大二上学期选修报名了Python,实际上也有点想学习的念头.早听说python处理一些重复性的事很在行?试试看吧!
thumbnail: /img/文章封面/Python封面.jpg
published: true
date: 2023-09-23 11:17:09
---

> 大二上学期选修报名了Python,实际上也有点想学习的念头.早听说python处理一些重复性的事很在行?  
>
> 课程笔记来自:[Python基础](https://www.bilibili.com/video/BV1qW4y1a7fU/?spm_id_from=333.999.0.0&vd_source=b19220b8f372f3a81aa8463fde694a63)

# Python 基础语法

### 字面量、数据类型

被写下来的固定值称之为字面量,有以下6种常用数据类型:

| 类型             | 描述                                                    | 说明                         |
| ---------------- | ------------------------------------------------------- | ---------------------------- |
| 数字(Number)     | 整数(int)<br>浮点(float)<br>复数(complex)<br>布尔(bool) | 复数形如4+3j,以j结尾表示的数 |
| 字符串(string)   | 描述文本的一种数据类型                                  | 由任意数量字符组成           |
| 列表(List)       | 有序的可变序列                                          | Python中最频繁使用的数据类型 |
| 元组(Tuple)      | 有序的不可变序列                                        | 有序记录不可变的Python数据   |
| 集合(Set)        | 无序不重复集合                                          | 可无序记录不重复的数据       |
| 字典(Dictionary) | 无序Key-Value集合                                       | 无序记录Key-Value型数据      |

`type()`能够查看字面量和变量的数据类型

```Python
114
5.14
"我去!"

# 甚至都不用声明类型...

"""
另外关于注释,单行注释是一个井号就ok,
多行注释是像这样三个引号.
不过md的代码块好像没给显示出来
"""
```

### 数据类型转换

| 语句(函数) | 说明            |
| ---------- | --------------- |
| int(x)     | 将x转换为整数   |
| float(x)   | 将x转换为浮点数 |
| str(x)     | 将x转换为字符串 |

* 任何类型都可以转换成字符串
* 字符串只有数字才能转换成数字
* 浮点转换整数会丢失精度(小数部分)

### 标识符

是用户在编程时用于给变量、类、方法等自定义的命名.  
能自定义标识符的有:
* 变量的名字
* 方法的名字
* 类的名字,等等...

注意:  
- 标识符不能以数字开头  
- 标识符不能使用关键字
- 标识符不推荐使用中文
- 标识符大小写敏感

### 运算符

除加减乘除外Python还有:

| 运算符 | 描述 | 实例             |
| ------ | ---- | ---------------- |
| //     | 取整 | 返回商的整数部分 |
| %      | 取余 | 返回商的余数部分 |
| **     | 指数 | 就是指数运算     |

除了基本运算,Python也支持赋值运算.  
**注意: Python 中是没有 ++ 和 -- 的**

### 字符串

1. 单引号定义法: `name='雲之残骸'`
2. 双引号定义法: `name="雲之残骸"`
3. 三引号定义法: `name="""雲之残骸"""`

其中,三引号定义法和多行注释写法相同,同样支持换行  
当使用变量接收它时,会变成字符串.  
不使用变量接收时,就可以当作多行注释.   

除了用 "+" 号拼接字符串, 我们还能使用占位符快速拼接字符串和变量  

```Python
name = "雲之残骸"
year = 114514
price = 19.5
massage = "我去,是 %s.今年是 %d 年,衬衫的价格是 %2.1f" % (name,year,price)

print(message)
```

> 输出: > 我去,是 雲之残骸 .今年是 114514 年,衬衫的价格是 19.5

其中,%s:
* % 表示:占位
* s 表示:将变量变成字符串放入占位的地方

这一点与c语言相同,包括支持 %f 浮点数.  
使用格式 %m.nf 能实现控制精度.

快速写法:
```Python
name = "雲之残骸"
year = 114514
price = 19.5

print(f"我去,是{name}.今年是 {year} 年,衬衫的价格是 {price}")
```

此方法不限数字类型,也不关心精度控制.

### 数据输入输出

* 输出: print  
  print输出默认换行,若想让输出换行,则可以:  

```Python
print("hello",end='')  
print("world",end='')  
```    
可以在结尾加上 `end=''` 即可不换行.
* 输入: input

```Python
# 可以直接把提示语句写在input中:

name = input("你是?")
print("明白了,你是 %s" % name)
```

input输入的数据默认都会当成**字符串** 
可以使用强制转换: num = input(num)

# Python 判断语句

**True = 1  
False = 0**

### if 判断语句

```Python
if 要判断的条件1:
    条件成立要做的事1
    条件成立要做的事2
elif 要判断的条件2:
    条件成立要做的事
elif 要判断的条件3:
    条件成立要做的事

...

else:
    条件不成立做的事
```

注意冒号不能省略,  
以及归属于if的代码块,需要四个空格缩进.      

可将input( )写入if中简化代码:
```Python
if int(input(请输入数字:))>3
```
例如将输入的数字与 3 比较判断大小.

# Python 循环语句

条件满足,便会去做对应的操作

### while 循环语句

```Python
while 条件:
    条件满足,要做的事.
```

嵌套循环时,一定要注意空格缩进来确定关系.

### for 循环

```Python
for 临时变量 in 待处理数据集:
    循环满足条件时执行的代码
```

* for循环无法定义循环条件,只能被动取出数据处理
* 依旧注意缩进格式

#### for 循环的变量作用域

临时变量, 在 **编程规范** 上, 作用范围(作用域), 只限定 for 循环内部.

如果在 for 循环外部访问的临时变量:
* 实际上是能访问的.
* 在规范上, 是不允许的. **不建议** 这样做.
* 如需访问, 可以在循环外定义它.


### range 语句

本质上是遍历: 序列类型

* 语法 1  
  
```Python  
range(num)
```

获取一个从 0 开始, 到 num 结束的数字序列 (**不含**num本身)
* 语法 2
  
```Python
range(num1,num2)
```  

获得一个从 num1 开始, 到 num2 结束的数字序列 (**不含**num2本身)

* 语法 3

```Python
range(num1,num2,step)
```
获得一个从 num1 开始,到 num2 结束的数字序列 (**不含**num2本身)  
数字之间的步长为step的值 (step默认为 1 )

### continue 和 break 关键字

* 临时跳过: contine  

中断本次循环, 直接进入下一次循环  

* 直接结束: break

直接结束循环

# Python 函数

函数是 **组织好的**, **可重复使用的**, 用来**实现特定功能的** 代码段.

### 定义函数

* def关键字

```Python
def 函数名(传入参数):
    函数体
    return 返回值
```
def关键字, 可以定义带有名称的函数.  
传入参数和返回值不需要可以省略.

* lambda关键字(匿名函数)

```Python
def func(add):
    result = add(1,2)

func(lambda x,y:x+y)
```

函数体只能写一行

### 函数的传入参数

作用是能让函数接收外部传入数据

```Python
def add(x,y): # 多个参数用逗号隔开

"""
函数说明文档
    :param x: 形参x的说明
    :param y: 形参y的说明
    :return: 返回值的说明
"""
    result = x + y # <--形式参数
    print(f"{x}+{y}={result}")
```

函数定义中的参数为 **形式参数**  
函数调用中的参数为 **实际参数**

传入的参数要与形式参数一一对应.

* **多个传入参数**

根据使用方式的不同, 函数有4种常见的参数使用方式.

1. **位置参数**: 调用函数时根据函数定义的参数位置来传递参数.
```Python
def user_info(name,age,gender):
    print(f"名字{name},年龄{age},性别{gender}")

user_info("TOM",20,"男")
```

2. **关键字参数**: 调用时用"键=值"形式传递参数
```Python
def user_info(name,age,gender):
    print(f"名字{name},年龄{age},性别{gender}")

user_info(gender="男",name="TOM",age=20)
```
3. **缺省参数**: 也就是设置默认值
```Python
def user_info(name,age,gender="男"):
    print(f"名字{name},年龄{age},性别{gender}")

user_info("TOM",20)
```

4. **不定长参数**: 也叫可变参数, 用于不确定调用的时候会传递多少个参数.

(1) 位置传递:
```Python
def user_info(*arg):
    print(args)

user_info("男","TOM",20)
```
传进的参数会被args变量收集, 成为一个元组.


(2) 关键字传递:
```Python
def user_info(**kwargs):
    print(kwargs)

user_info(gender="男",name="TOM",age=20)
```
传进的参数会被kwargs变量收集, 成为一个"键=值"的字典.

#### 函数作为参数传递

传入函数的不仅可以是数据, 也可以是计算逻辑.  

传入数据:
```Python
def add(x,y):
    return x + y
```

传入一个计算逻辑(函数):
```Python
def func(add):
    result = add(1,2)
    print(result)

def add(x,y):
    return x + y
```

### 函数的返回值

函数的返回值能在函数执行完毕后, 返回 **给调用者** 结果.

* 注意: 函数体在遇到return后就结束了, 不会执行return后的代码.

当函数没有使用return语句返回数据时, 会返回 **字面量 None**,   
> 无返回值的函数, 返回的内容是: None  
> 无返回值的函数, 返回的内容类型是: <class 'NoneType'>

表示空的, 没有意义.

在if判断中, None等同于False  

* **多个返回值**

要使函数返回多个返回值, 可以用逗号分隔.

```Python
def test_return():
    return 1,2,3

x,y,z = test_return()
print(f"{x},{y},{z}")
```

### 变量的作用域

变量的作用域指的是变量的**作用范围**.  
主要分为两类: **局部变量** 和 **全局变量**

1. **局部变量**

定义在函数体内部的变量, 只在函数体内部生效  

能在函数体内部临时保存数据, 函数调用完后销毁

2. **全局变量**

能在函数体内外都能生效的变量.

3. **global关键字**

可以让函数内定义的局部变量转换为全局变量以修改.

# Python 数据容器

数据容器是能够存储多个元素的Python数据类型

**list [列表]**  
**tuple (元组)**  
**str "字符串"**  
**set {集合}**  
**dict(字典)**  

它们各自有各自的特点

## 列表(list)

```Python
# 字面量
[元素1,元素2,元素3,元素4,...]

#定义变量
变量名称 = [元素1,元素2,元素3,元素4,...]

# 定义空列表
变量名称 = []
变量名称 = list()
```

元素的数据类型没有任何限制, 甚至元素也可以是列表, 这样就定义了嵌套列表

### 列表的下标索引

列表的每个元素, 都有编号称之为下标索引

从前向后看, 下标索引从 **0 开始递增.**  
从后向前看, 下标索引从 **-1开始递减.**

` 列表名称[ 下标 ] `即可使用下标索引取出元素

### 列表的方法

把一个函数封装到类当中, 这个函数就会被称作为 **方法**

* 查找某元素的下标  
`列表. index(要查找的元素)`

* 修改特定下标索引的值  
`列表[下标] = 要修改的值`

* 插入元素  
`列表.insert(下标, 插入的元素)`

* 追加元素(到末尾)  
`列表.append(要插入的元素)`  
也可以批量追加元素:  
`列表.extend(其他数据容器)`

* 删除元素(匹配下标)  
`del列表[下标]`  
也可以通过pop取出元素达到删除效果:  
`列表.pop(下标)`  
pop能得到取出的元素.

*  删除匹配(指定)的元素  
`列表.remove(元素)`  
只能删掉第一个匹配的元素.

* 清空  
`列表.clear()`

* 统计指定元素在列表内的数量  
`列表.count(元素)`

* 统计列表内总元素个数  
`len(列表)`

### 列表的特点

* 可以容纳 **多个, 类型不同** 的元素
* 元素是 **有序存储** 的
* 允许 **增加删除** 元素, 允许 **重复数据** 存在.

### 列表的遍历

1. while 循环

```Python
index = 0
while index < len(列表):
    元素 = 列表[index]
    对元素进行处理
    index += 1
```
while循环更灵活

2. for 循环

```Python
for 临时变量 in 数据容器:
    对临时变量进行处理
```
for循环更简单

## 元组(tuple)

定义完成后, 就不可修改. 其他特点与列表类似.

```Python
# 定义元组字面量
(元素,元素,...,元素,)
# 定义元组变量
变量名称 = (元素,元素,...,元素,)
# 定义空元组
变量名称 = () # 方式1
变量名称 = tuple() #方式2
```

虽然元组元素不能修改, 但是元组嵌套中的列表能修改.

### 元组的方法

| 方法                 | 作用                                               |
| -------------------- | -------------------------------------------------- |
| `元组.index("元素")` | 查找某个数据, 如果数据存在返回对应的下标, 否则报错 |
| `元组.count("元素")` | 统计某个数据在当前元组出现的次数                   |
| `len(元组)`          | 统计元组内的元素个数                               |

## 字符串(str)

是字符的容器, 一个字符串可以存放任意数量的字符.

字符串同元组一样, 是 **无法修改** 的数据容器.

### 字符串的方法

* 字符串的替换  
`字符串.replace(字符串1, 字符串2)`  
能将老字符串替换成一个新的字符串

* 字符串分割  
`字符串.split(分隔符字符)`  
字符串本身不变, 得到一个新的列表对象

* 字符串规整操作  
`字符串.strip()` 去掉前后空格  
`字符串.strip(字符串)` 去掉前后指定字符串

* 统计字符串某个字符串的出现次数  
`字符串.count("字符串")`

* 统计字符串长度
`len(字符串)`

## 序列

内容连续, 有序, 可使用下标索引的一类数据容器.  

列表, 元组, 字符串, 均可视为序列.

### 序列的常用操作

* 切片  
`序列[起始下标:结束下标:步长]`  
从一个序列中, 取出一个子序列, 会得到一个新字符串    
步长表示取元素的间隔

起始下标不写 表示从头
结束下标不写 表示到尾
步长为负 表示倒序

## 集合(set)

不支持元素重复(自带去重功能), 并且内容无序.

内容无序, 导致不支持下标索引访问.

```Python
# 定义集合字面量
{元素, 元素, ... , 元素}
# 定义集合变量
变量名称 = {元素, 元素, ... , 元素}
# 定义空集合
变量名称 = set()
```

### 集合的常用操作

* 添加新元素  
`集合.add(元素)`  
将指定元素, 添加到集合内.  
修改集合本身, 添加了新元素.


* 移除元素 
`集合.remove`  
将指定元素, 从集合中移除.  
集合本身被修改, 移除了元素.

* 从集合中随机取出元素  
`集合.pop`  
由于集合无序, 无法指定取出. 因此达到随机取出的效果.  
集合本身被修改, 元素被移除.

* 清空集合  
`集合.clear`

* 取出2个集合的差集  
`集合1.difference(集合2)`  
原集合1,2不变, 得到一个新集合.

* 消除2个集合的差集  
`集合1.difference_updata(集合2)`  
集合1被修改, 集合2不变.

* 2个集合合并  
`集合1.union(集合2)`  
原集合1,2不变, 得到一个新集合.

* 统计元素个数  
`len(集合)`

### 集合的遍历

由于无序, 因此不支持while循环.  

但支持for循环遍历:

```Python
for element in 集合:
    要对element的操作
```
### 字典

```Python
# 定义字典字面量
{key:value,key:value,...,key:value}
# 定义字典变量
my_dict = {key:value,key:value,...,key:value}
# 定义空字典
my_dict = {}
my_dict = dict()
```

可以通过Key, 取到对应的Value.  
存储的元素 Key:value 键值对.  
不支持下标索引.

> 字典嵌套:
> 姓名|语文|数学
> ---|---|---
> 张三|95|92
> 李四|94|98
>
> ```Python
>   socre_dict = {
>    "张三":{
>           "语文":95
>           "数学":92
>   }
> }
> ```


### 字典的常用操作

* 新增/更新元素  
`字典[Key] = Value`  
对已经存在的Key执行, 就会更新Value值.

* 删除元素  
`字典.pop(Key)`  

* 清空元素  
`字典.clear()`

* 获取全部的key  
`字典.keys()`  

遍历字典  

第一种方法:
```Python
keys = my_dict.keys()

for key in keys:
    要执行的操作
```

第二种方法:
```Python

for key in my_dict:
    要执行的操作
```

* 统计字典内元素数量:  
`len(字典)`

## 数据容器总结

数据容器可以从以下视角进行简单分类:  
* **是否支持下标索引**  
序列类型(支持): 列表, 元组, 字符串  
非序列类型(不支持):集合, 字典

* **是否支持重复元素**  
序列类型(支持): 列表, 元组, 字符串  
非序列类型(不支持):集合, 字典

* **是否可以修改**  
支持: 列表, 集合, 字典  
不支持: 元组, 字符串

 | 属性     | 列表                           | 元组                           | 字符串         | 集合           | 字典                                     |
 | -------- | ------------------------------ | ------------------------------ | -------------- | -------------- | ---------------------------------------- |
 | 元素类型 | 任意                           | 任意                           | 仅字符         | 任意           | key:除字典外任意类型 <br> value:任意类型 |
 | 下标索引 | -                              | -                              | -              | 不支持         | 不支持                                   |
 | 重复元素 | -                              | -                              | -              | 不支持         | key不支持                                |
 | 可修改性 | -                              | 不支持                         | 不支持         | -              | -                                        |
 | 数据有序 | -                              | -                              | -              | 无序           | 无序                                     |
 | 使用场景 | 可修改的, <br>带重复的数据记录 | 不可修改, <br>带重复的数据记录 | 一串字符的记录 | 去重的数据记录 | 以Key检索Value的记录                     |

# Python 文件操作

文件操作步骤分为: 打开, 读写, 关闭

### 打开  
`open(name,mode,encoding)`  
name: 文件的名称/路径  
mode: 有只读(r), 写入(w), 追加(a)等.  
encoding: 编码格式(推荐使用UTF-8)  

### 读取
1. read()方法  
`文件对象.read(num)`  
num表示要从文件中读取的数据的长度(单位是字节), 如果省略, 就会读取文件中所有的数据.

2. readlines()方法  
`文件对象.readlines()`  
readlines可以按照行的方式把整个文件一次性读取, 返回一个列表, 其中每一行的数据为一个元素.

3. readline()方法  
`文件对象.readline()`  
一次读取一行内容

### 写入
`文件对象.write("写入内容")`
```Python
f = open('python.txt', 'w')

f.write(hello world)

f.flush()
```
为避免频繁操作硬盘而导致效率低, 内容会先积攒到程序的内存中(缓冲区), 当调用flush时, 内容才会真正写进文件.  
.close()方法也会自带.flush()方法  

w模式下写入时, 文件不存在, 会创建新文件. 文件存在, 会清空原有内容.

### 追加
方法同w, 有:

wirte(), 写入内容  
flush(), 刷新内容到硬盘

a同w, 文件不存在, 会创建新文件. 不同的是:文件存在, 会在原有内容后继续写入.

### 关闭  
1. `文件对象.close()`  
解除文件占用

2. `with open() as 文件对象`  
自动关闭文件

# Python 异常

### 异常处理/捕获异常

基本语法:
```Python
try:
    可能发生错误的代码

except:
    如果出现异常要执行的代码

# [ ]中括号代表代码可选
[else:]
    没有异常时执行的代码

[finally:]
    无论是否异常, 都会执行的代码
```

若要捕获指定的异常:

```Python
except 错误类型 as e(别名):
    出现异常要执行的操作
```

若要捕获多个异常, 可以通过元组书写:

```Python
except (错误类型1,错误类型2) as e:
    出现异常要执行的操作
```

捕获所有异常:

```Python
except Exception as e:
    出现异常要执行的操作
```

异常具有传递性.

# Python 模块

是一个Python文件(以.py结尾), 里面有类, 函数, 变量等. 我们可以导入模块使用.

导入方式:
```Python
[from 模块名] import [模块|类|变量|函数|*][as 别名]

#import会导入整个模块, 通过 . 能使用其中所有功能
import 模块名1, 模块名2
模块名.功能名()

#form import 能具体导入某个功能
from 模块名 import 功能名
功能名()

#使用 * 导入模块的全部功能, 只是写法不同而已. 
form 模块名 import *
功能名()
```
如果使用这种方式导入, 模块文件含有`__all__`变量, 就只会导入列表all中记录的元素:
```Python
__all__ = [函数1,函数2]

函数1

函数2

函数3
# 只会导入 1 和 2
```
### 自定义模块

新建一个`my_module1.py`的文件,内容如下:
```Python
def test(a, b):
    print(a + b)
```

在另一个文件中,使用这个Python模块:
```Python
import my_module1

my_module1.test(10, 20)
```

当导入两个同名的模块时, 后调用的会覆盖先调用的.

如果想让模块调用时不执行, 而在测试时执行, 可以添加:
```Python
导入模块要执行的代码
if __name__ == '__main__':
    导入模块不会执行的代码
```

### Python 包

本质是一个包含 `__init__.py` 文件的文件夹, 能存放模块.

没有 `__init__.py` ,就不是包.

在Python程序的生态中, 有许多第三方包,例如: 
* 科学计算的 numpu 包
* 数据分析的 pandas 包
* 大数据计算的 pyspark apache-flink 包
* 图形可视化的 matplotlib pyrcharts
* 人工智能的 tensorflow
* 等等

#### 安装第三方包

使用Python内置的pip程序, 在命令提示符中输入:
```cmd
pip install 包名称
```
即可通过网络安装包.

#### 优化下载的方法

让其链接国内的网站进行下载
```cmd
pip instal -i https://pypi.tuna.tsinghua.edu.cn/simple 包名称
```

https://pypi.tuna.tsinghua.edu.cn/simple 是清华大学提供的一个网站, 可供pip程序下载第三方包.


# 面向对象 

### 数据的组织

生活中, 可以设计一个表格, 将数据整齐地统计出来, 在程序中也有相同的思路.

1. 在程序中设计表格, 称之为: **设计类(class)**
2. 在程序中打印生产表格, 称之为: **创建对象**
3. 在程序中填写表格, 称之为: **对象属性赋值**

### 类的定义和使用

```Python
# classs是关键字, 表示要定义类了
class 类名称:
    # 类的属性: 定义在类中的变量(成员变量)
    name = None 

    # 类的行为: 定义在类中的函数(成员方法)
    def say(self):
        print("hello world!")
```

self关键字是成员方法定义时, 必须填写.   
它用来表示类对象自身的意思.  
在方法内部, 想要访问类的成员变量, 必须使用self.

### 类和对象  

基于类创建对象的语法: `对象名 = 类名称()`  

```Python
class Wolf:
    name = None
    age = None
    fur = None

wolf1 = Wolf()
wolf1.name = "沃里克"
wolf1.age = 31
wolf1.fur = "gray"

print(wolf1.name)
...
```

Python类也可以使用:  `__init__` (方法)构造方法  

能使创建类对象 (构造类) 的时候, 会自动执行.  
在创建类对象 (构造类) 的时候, 将传入参数自动传递给 `__init__` 方法使用

例如:

```Python
class Wolf:

    def __init__(self, name, age, tel):
        self.name = name
        self.age = age
        self.fur = fur
        print("此构造方法会自动执行")

Wolf1 = Wolf("沃里克", 31, "gray")

print(wolf1.name)
...
```

### 常用的类内置方法

除了 `__init__` 构造方法外, Python类中还有其他的类内置方法.  
这些内置的类方法, 各有各自特殊的功能, 这些内置方法我们称之为: **魔术方法**

#### `__str__` 字符串方法  
当类对象需要被转换为字符串之时: 

```Python
class Wolf:
    ...

wolf1 = Wolf("沃里克", gray)

print(wolf1)
print(str(wolf1)) #输出地址值, 没什么实际作用

```
会输出内存地址.
我们可以通过 `__str__` 方法, 控制类转换为指定的字符串

```Python
class Wolf:
    ...

    def __str__(self):
        return f"有一只名叫{self.name}的{self.fur}毛狼!"

wolf1 = Wolf("沃里克", gray)

print(wolf1)
print(str(wolf1)) #会按照__str__设定的输出.

```

#### `__lt__`小于大于符号比较方法 

无法直接对两个对象进行比较.  
但使用 `__lt__` 方法, 可以同时完成 大于和小于 的比较.

```Python
class Wolf:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __lt__(self, other):
        return self.age < other.age

wolf1 = Wolf("沃里克", 31)
wolf2 = Wolf("布莱泽", 25)

print(wolf1 < wolf2) #返回 false
print(wolf1 > wolf2) #返回 true 
```

而小于等于大于等于可以使用: `__le__`   
同理, 判断两个对象是否相等: `__eq__`  
用法都同 `__lt__`

# 面向对象的三大特性

面向对象编程, 是许多编程语言都支持的一种编程思想.  
简单理解就是: 基于模板 (类) 去创建实体对象 (对象), 使对象完成功能开发.

面向对象包含 3 大主要特性:

1. 封装
2. 继承
3. 多态

## 封装

封装表示将现实世界事物的:
* 属性
* 行为

封装到类中, 称为:
* 成员变量
* 成员方法

从而完成程序对现实世界事物的描述

### 私有成员 

有的属性呵行为不公开, 我没将其称之为私有成员形式, 定义私有成员的方式非常简单, 只要:
* 私有成员变量: 变量名以__开头(2个下划线)
* 私有成员方法: 方法名以__开头(2个下划线)

私有成员只能被内部类中的其他成员访问.


# 结语

> wow! 基础学完力!
> 不过速通疏漏还挺多, 继续加油吧!